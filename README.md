# 多項產品程序圖(Multi-Process chart)python實作

## 目錄
- [上手指南](#上手指南)
  - [安裝環境](#安裝環境)
- [定義]()
  - [公式解釋](#公式解釋)
  - [分析邏輯](#分析邏輯)
  - [問題需求](#問題需求)
- [程式碼部分]()
  - [程式碼實現&功能](#程式碼功能)
  - [使用到的演算法](#演算法解釋)
- [相關連結](#相關網址)

## **安裝環境**

1. 使用python pip指令
```python
pip install -r requirements.txt
```

2. 確保python版本>=3.12
```python
python --version
```

## 公式解釋
若某一產品生產全程需要移動 ${m_{i}}$ 個單位，而其預估總產量為 ${Q_{i}}$ ，則 ${m_{i}\times Q_{i}}$ 為i項產品之總移動單位，多項產品程序圖的目標就是各項產品在各個作業之間的總移動單位(Z)最小化，以數學表示，其目標函數如下:

$${
\min z =\sum_{i=1}^{n} m_{i}\times Q_{i} 
}$$

## 舉例

我會給一個陣列(這個陣列代表FTC From-To Chart從至圖)，陣列的第一列是零件順序(從1~n個)，第一行是部門單位(1~m個)
部門和部門之間為一個單位(部門1到部門2為一個單位)

Ex: 

$${
\begin{bmatrix}
 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & \\
 1 & 1 & 0 & 2 & 3 & 0 & 0 & 4 & 0 & 5 & 6 & \\
 2 & 1 & 7 & 3 & 4,5 & 6 & 2 & 0 & 8 & 9 & 10 & \\
 3 & 1 & 0 & 3 & 0 & 4 & 2 & 0 & 5 & 0 & 6 & \\
 4 & 1 & 2 & 0 & 0 & 5,6,7 & 0 & 3 & 4 & 0 & 8 & \\
 5 & 1 & 0 & 2 & 3 & 5,6 & 4 & 7 & 0 & 8 & 9 & \\
 6 & 1 & 0 & 6,7 & 0 & 2,3,4 & 0 & 5 & 0 & 0 & 8 & \\
 7 & 1 & 2,5 & 3 & 7 & 6 & 4 & 0 & 0 & 8 & 9 & \\
 8 & 1 & 4 & 0 & 6 & 5 & 2 & 3 & 0 & 0 & 7 & \\
 9 & 1 & 3,4 & 2 & 0 & 0 & 0 & 0 & 5,6 & 0 & 7 & \\
 10 & 1 & 5 & 3 & 0 & 4 & 2 & 0 & 0 & 6 & 7 & \\
 11 & 1 & 0 & 2,3 & 0 & 4,5 & 0 & 0 & 7,8 & 6 & 9 &
\end{bmatrix}
}$$

## 分析邏輯

有10個部門，11個零件
裡面的內容代表加工順序

EX:

第二列是零件1加工順序(先從1部門(步驟1)->3部門(步驟2)->4部門(步驟3)->7部門(步驟4)->9部門(步驟5)->10部門(步驟6))
->總共要移動9個單位

第三列是零件2加工順序(先從1部門(步驟1)->6部門(步驟2)->3部門(步驟3)->4部門(步驟4)->4部門(步驟5)->5部門(步驟6)->2部門(步驟7)->8部門(步驟8)->9部門(步驟9)->10部門(步驟10))
->總共要移動21個單位(步驟4和步驟5因為在同一個部門，所以不用加上移動單位)

## 問題需求

透過更改部門位置，來達成最佳化減少部門和部門間移動的單位

更改部門所在的行

## 程式碼功能

* 統一資料格式(Latex格式轉python List)
* 增加隨機生成矩陣功能
* 多演算法比較
* 添加偽隨機數功能
* 統計資訊並分析

## 演算法解釋

## 1. 模擬退火算法 (Simulated Annealing)

> 模擬退火算法是一種啟發式優化算法，靈感來自於金屬退火過程。
### 時間複雜度分析
| 情況 | 複雜度 | 說明 |
|------|--------|------|
| 最壞情況 | O(n²) | 當溫度下降過慢時 |
| 平均情況 | O(n log n) | 標準參數設置下 |
| 最佳情況 | O(n) | 當問題結構簡單時 |

### 實際執行時間
| 問題規模 | 執行時間 | 說明 |
|----------|----------|------|
| 小型問題 (n < 10) | 數秒至數十秒 | 適合快速測試 |
| 中型問題 (10 ≤ n < 50) | 數分鐘 | 適合實際應用 |
| 大型問題 (n ≥ 50) | 數小時 | 需要較長等待時間 |

### 工作原理
- 從一個初始解開始
- 在每次迭代中，隨機生成一個鄰近解
- 根據溫度參數決定是否接受較差的解
- 隨著溫度逐漸降低，接受較差解的概率也降低
- 最終收斂到一個較好的解

### 優點
- 能夠避免陷入局部最優解
- 適用於複雜的優化問題
- 參數可調，靈活性高

## 2. 貪婪演算法 (Greedy Algorithm)

> 貪婪演算法是一種簡單直接的優化方法。
### 時間複雜度分析
| 情況 | 複雜度 | 說明 |
|------|--------|------|
| 最壞情況 | O(n²) | 當每次選擇都需要遍歷所有選項 |
| 平均情況 | O(n log n) | 使用優先級隊列時 |
| 最佳情況 | O(n) | 當選擇順序固定時 |

### 實際執行時間
| 問題規模 | 執行時間 | 說明 |
|----------|----------|------|
| 小型問題 (n < 10) | 毫秒級 | 幾乎即時完成 |
| 中型問題 (10 ≤ n < 50) | 數秒 | 適合實時應用 |
| 大型問題 (n ≥ 50) | 數十秒至數分鐘 | 仍可接受 |

### 工作原理
- 在每一步選擇當前看起來最好的選項
- 不考慮未來的影響
- 通常用於快速找到可行解

### 優點
- 實現簡單
- 運行速度快
- 適用於某些特定問題

### 缺點
- 可能無法找到全局最優解
- 容易陷入局部最優

## 3. 中心放置法 (Center Placement)

> 中心放置法是一種基於流量的布局策略。
### 時間複雜度分析
| 情況 | 複雜度 | 說明 |
|------|--------|------|
| 最壞情況 | O(n log n) | 排序時間主導 |
| 平均情況 | O(n log n) | 標準實現 |
| 最佳情況 | O(n) | 當數據已排序時 |

### 實際執行時間
| 問題規模 | 執行時間 | 說明 |
|----------|----------|------|
| 小型問題 (n < 10) | 毫秒級 | 即時完成 |
| 中型問題 (10 ≤ n < 50) | 數秒 | 快速響應 |
| 大型問題 (n ≥ 50) | 數十秒 | 效率較高 |

### 工作原理
- 將流量最大的部門放在中心位置
- 其他部門按照流量大小依次向兩側放置
- 考慮部門之間的相對位置關係

### 優點
- 直觀易懂
- 計算速度快
- 適合流量分布明顯的問題

## 4. 基因演算法 (Genetic Algorithm)

> 基因演算法是一種基於生物進化原理的優化算法。
### 時間複雜度分析
| 情況 | 複雜度 | 說明 |
|------|--------|------|
| 最壞情況 | O(p * g * n²) | 當種群規模和迭代次數都很大時 |
| 平均情況 | O(p * g * n log n) | 標準參數設置下 |
| 最佳情況 | O(p * g * n) | 當適應度計算簡單時 |

### 實際執行時間
| 問題規模 | 執行時間 | 說明 |
|----------|----------|------|
| 小型問題 (n < 10) | 數秒至數十秒 | 適合實驗性應用 |
| 中型問題 (10 ≤ n < 50) | 數分鐘至數十分鐘 | 需要耐心等待 |
| 大型問題 (n ≥ 50) | 數小時 | 建議使用高性能計算機 |

### 工作原理
- 維護一個解的群體（種群）
- 通過選擇、交叉和變異操作產生新一代
- 保留較好的解，淘汰較差的解
- 經過多代進化找到較優解

### 優點
- 能夠處理複雜的優化問題
- 可以找到多個較好的解
- 具有較強的全局搜索能力

### 缺點
- 參數設置較為複雜
- 計算時間可能較長
- 需要較大的種群規模

## 應用場景比較

| 演算法 | 適用場景 | 時間複雜度 | 建議使用規模 | 執行時間特點 |
|--------|----------|------------|--------------|--------------|
| 模擬退火 | 適合需要避免局部最優的複雜問題 | O(n²) | 中小型問題（n < 50） | 中等，可接受 |
| 貪婪算法 | 適合需要快速求解的簡單問題 | O(n²) | 所有規模問題 | 快速，即時 |
| 中心放置 | 適合流量分布明顯的布局問題 | O(n log n) | 所有規模問題 | 非常快速 |
| 基因算法 | 適合需要全局搜索的複雜問題 | O(p * g * n²) | 中小型問題（n < 50） | 較慢，但結果好 |

---

## 相關網址

線上latex->[前往](https://www.latexlive.com/)

模擬退火演算法->[前往](https://zh.wikipedia.org/zh-tw/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB)

貪婪演算法->[前往](https://www.hello-algo.com/zh-hant/chapter_greedy/greedy_algorithm/)

中心放置: 在 **《生產與管理》及《作業管理》** 書籍裡有提及

基因算法->[前往](https://zh.wikipedia.org/zh-tw/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95)
